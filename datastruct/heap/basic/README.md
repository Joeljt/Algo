## 堆

堆的实现核心在于两个操作：

- 上浮：将新插入的元素与其父节点比较，如果新元素大于父节点，则交换位置，直到满足堆的性质或到达根节点。
- 下沉：将堆顶元素与其子节点比较，选择较大的子节点进行交换，直到满足堆的性质或到达叶子节点。

#### 上浮

```c
void swim(int* arr, int i) {
  // 如果当前节点大于其父节点，则交换位置
  while (i > 0 && arr[i] > arr[(i - 1) / 2]) {
    swap(arr[i], arr[(i - 1) / 2]);
    // 继续上浮
    i = (i - 1) / 2;
  }
}
```

#### 下沉

```c
void sink(int* arr, int i, int length) {
  // 只要当前节点还有子节点，就需要尝试下沉
  // 2 * i + 1 是左子节点，2 * i + 1 < length 表示当前节点还有子节点
  while (2 * i + 1 < length) {
    // 先判断左子节点
    int j = 2 * i + 1;
    // 如果右子节点大于左子节点，则选择右子节点
    if (j + 1 < length && arr[j + 1] > arr[j]) j++;
    // 如果当前节点大于等于子节点，则停止下沉
    if (arr[i] >= arr[j]) break;
    // 交换位置
    swap(arr[i], arr[j]);
    // 继续下沉
    i = j;
  }
}
```

#### 堆排序

[堆可以用来实现排序](../sorting/heap/README.md)，通过不停地取出堆顶元素，然后重新维护剩余元素的堆性质，从而实现排序。

整体上，每次 heapify 的操作复杂度为 O(logn)，遍历整个数组的操作复杂度为 O(n)，所以堆排序的复杂度为 O(nlogn)。

```c
void heapSort(int* arr, int length) {
   // heapify
   for (int i = length / 2 - 1; i >= 0; i--) {
      sift_down(arr, i, length);
   }
   // sort
   for (int i = length - 1; i >= 0; i--) {
      swap(arr[0], arr[i]);
      sift_down(arr, 0, i);
   }
}
```

### Q&A

#### 完全二叉树的性质决定了它可以用数组来表示，还是想用数组来表示二叉树，才创造了完全二叉树这个概念？

普通的二叉树无论使用递归还是迭代，都很难做到高效地增删改查，所以就想用数组描述一棵树，同时尽可能保证数据的连续性，在这个基础上发现只要二叉树满足除了最后一层以后都是满的，并且叶子结点尽可能的在左子树上，就可以用数组表示一棵二叉树，从而实现 O(1) 的操作复杂度。然后又在这个基础上，规定了一些顺序条件限制，从而额外发展出来堆这个基于用数组表示的二叉树的高级数据结构。

完全二叉树更像是一个为了满足"用数组高效表示"这个需求而设计的概念，它的定义就是为了确保在数组表示时不会有空洞，这种设计反过来为堆这样的数据结构提供了理论基础。

#### 出队时 data[0] 一定是最值吗?

是的，在堆中，data[0] 一定是最值：

- 大顶堆：
  - data[0] 是最大值
  - 因为堆序性要求每个父节点都大于等于其子节点
- 小顶堆：
  - data[0] 是最小值
  - 因为堆序性要求每个父节点都小于等于其子节点

这是堆的一个基本性质，也是为什么堆可以用来实现优先队列的原因。通过 pop 操作，我们总是能在 O(log n) 时间内获取并移除堆顶的最值。

#### 堆是"逻辑上的树，物理上的数组"

```
物理存储（数组）：
[10, 7, 9, 3, 5, 6]

逻辑结构（完全二叉树）：
     10
   /    \
  7      9
 / \    /
3   5  6

索引对应关系：
数组索引：  0  1  2  3  4  5
数组元素： [10,7, 9, 3, 5, 6]
树的层级：  1  2  2  3  3  3
```

堆实际上就是在一个数组里，通过逻辑层的划分构建出来一个逻辑树，在这个树里，因为要尽可能保证数组连续，所以规定完全二叉树的叶子结点尽可能靠左，也就是紧贴着数组元素。

#### 堆的父子节点索引关系

- 父节点索引：`(i-1)/2`
- 左子节点索引：`2i + 1`
- 右子节点索引：`2i + 2`

#### 堆和优先队列

堆关注的始终是最顶部的值，最大还是最小取决于具体的实现，所以本质上堆还是队列。

- 出队（获取并移除堆顶元素）是 O(log n)
- 入队（插入新元素并调整堆）是 O(log n)

普通队列的插入和删除可能是 O(n)（特别是需要保持顺序时），堆通过 swim 和 sink 操作高效维护顺序。而且在 swim 和 sink 的过程中，可以根据具体的条件对元素进行比较，从而以 O(logn) 的复杂度完成按自定义规则入队，从而实现一个带有优先级的队列，而不是普通的先进先出的队列。

#### 为什么出队后要把末尾元素放到堆顶，然后进行下沉？

- 保持数组连续性
- 保持完全二叉树的结构
- 最小化操作复杂度

为了保持数组连续性，必须把末尾元素放到堆顶，否则数组就会产生空白位置；而遍历向前移动元素，则需要 O(n) 的复杂度，但是把末尾元素放到堆顶，然后进行下沉操作，这样只需要 O(logn) 的复杂度。

这就像在一个满教室换座位：

- 如果所有人都向前移动一个位置，则需要 O(n) 的复杂度
- 如果让最后一个人坐到第一个位置，然后其他人依次向前移动一个位置，再进行几次调换即可
  - 最后一个人坐到第一个位置，就相当于把末尾元素放到堆顶 O(1)
  - 其他人依次向前移动一个位置，就相当于进行下沉操作 O(logn)

#### 最后一个元素的值是否会影响整个下沉操作的复杂度？

最后一个元素的值确实会影响下沉的具体步数，但不会影响复杂度的量级。最好情况下交换一次即可，最坏情况下需要交换到叶子结点为止。

但是最坏情况下的复杂度仍然是 O(logn)，因为下沉操作最多需要从根节点一直交换到叶子节点，因此最大交换次数就是树的高度，而树的高度是 O(logn)。

#### 假设一个三个元素的最小堆，1 2 3 和 1 3 2 有区别吗?

没有区别，因为堆序性只要求父节点小于等于子节点，而没有要求左右子节点的大小关系。

在堆的操作过程中，以下几点是关键：

1. 堆顶是极值：
   - 对于最小堆，堆顶（根节点）是整个堆中最小的元素。
   - 对于最大堆，堆顶是整个堆中最大的元素。
2. 完全二叉树的结构：
   - 堆总是保持完全二叉树的结构，这意味着每一层都是满的，除了最后一层，且最后一层的节点尽可能靠左。
3. 父子节点关系：
   - 在最小堆中，每个父节点的值小于或等于其子节点的值。
   - 在最大堆中，每个父节点的值大于或等于其子节点的值。
4. 子树的左右节点值可能变化：
   - 在 swim 和 sink 操作过程中，子树的左右节点的值可能会发生变化。
   - 这些操作的目的是维护堆的性质（父节点与子节点的关系），而不是维护子节点之间的顺序。

因此，堆的内部结构在 swim 和 sink 操作后可能会发生变化，但堆的基本性质（堆顶是极值和完全二叉树结构）始终保持不变。
