## 堆排序

堆排序是一种高级排序，依赖堆这种数据结构实现排序，时间复杂度为$O(n\log n)$。

堆排序的实现思路是：

1. 将数据构建成一个最大堆；
2. 将堆顶元素与队尾元素进行交换，这样就实现了将最大值放到末尾；
3. 排除掉末尾元素，将剩下的元素重新构建成最大堆；
4. 重复 2 和 3 步骤，直到所有元素都排序完成。

在整个过程中，建堆的操作是 O(logn) 级别的，然后在排序过程中会遍历整个数组，不停进行建堆操作，一共重复 n 次，所以时间复杂度为 O(nlogn)。

### 实现

#### 朴素版本

我们先尝试写一版最朴素的堆排序，然后基于这个版本进行优化。

我们可以直接将数组构建成一个最小堆，然后在遍历过程中不停调用 pop 方法，把返回值放入一个新数组中就可以了。

```c
void heapSort(int* arr, int length) {
  Heap* heap = createHeap(arr, length);
  for (int i = 0; i < length; i++) {
    arr[i] = pop(heap);
  }
  freeHeap(heap);
}
```

但是这个版本的问题在于：

1. 需要额外创建一个堆结构来存储数据；
2. 每次 pop 操作实际上都会重新调整堆，增加了不必要的开销。

我们知道，堆本质上就是一个数组，所以我们可以直接对原数组进行堆化操作，原地排序。

#### heapify

根据堆的实现，调整堆的思路有两种：

1. 入队时对新入队的元素上浮，自下而上调整，每次比对当前节点与父节点的大小。
2. 出队后从根节点开始下沉，自上而下调整，每次比对当前节点与其左右子节点的大小。

我们需要把一个无序数组构建成一个堆，也可以选择这两种思路。

##### 自下而上

```c
void heapify(int* arr, int length) {
  for (int i = 0; i < length; i++) {
    siftUp(arr, i);
  }
}
```

很明显，与朴素版本的逻辑类似，遍历整个数组，对每个元素进行 O(logn) 级别的调整，所以时间复杂度为 O(nlogn)。

##### 自上而下

```c
void heapify(int* arr, int length) {
  for (int i = length / 2 - 1; i >= 0; i--) {
    siftDown(arr, length, i);
  }
}
```

但是如果我们使用自上而下的方式，因为叶子节点不需要调整，我们只需要从最后一个非叶子节点开始，倒序遍历到根节点，对每个节点进行下沉操作即可。

在一棵树中，叶子节点的数量大约会占到整个树的一半，所以我们这里只需要遍历一半的节点。

同时，虽然理论上单个节点的下沉操作最坏是 O(logn)，但由于树的性质，大多数节点都在树的下半部分，它们下沉的距离很短，需要完整下沉的节点数量很少，只有堆顶元素才需要下沉 O(logn) 的距离。

这种不均匀的操作分布使得总体复杂度降到了 O(n) 级别。

#### 堆排序

有了以上的堆化操作，我们就可以进行堆排序了。

```c
void heapSort(int* arr, int length) {
    // 从最后一个非叶子节点开始，自上而下调整堆
    for (int i = length / 2 - 1; i >= 0; i--) {
        siftDown(arr, length, i);
    }
    // 排序
    for (int i = length - 1; i > 0; i--) {
        // 将堆顶元素与末尾元素交换
        swap(arr, 0, i);
        // 排除掉末尾元素，将剩下的元素重新构建成最大堆
        siftDown(arr, i, 0);
    }
}
```
