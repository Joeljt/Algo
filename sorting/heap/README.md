## 堆排序

堆排序是一种高级排序，依赖堆这种数据结构实现排序，时间复杂度为$O(n\log n)$。

堆排序的实现思路是：

1. 将数据构建成一个最大堆；
2. 将堆顶元素与队尾元素进行交换，这样就实现了将最大值放到末尾；
3. 排除掉末尾元素，将剩下的元素重新构建成最大堆；
4. 重复 2 和 3 步骤，直到所有元素都排序完成。

在整个过程中，建堆的操作是 O(logn) 级别的，然后在排序过程中会遍历整个数组，不停进行建堆操作，一共重复 n 次，所以时间复杂度为 O(nlogn)。

### 实现

#### 乞丐版本

我们先尝试写一版最朴素的堆排序，然后基于这个版本进行优化。

我们可以直接将数组构建成一个最小堆，然后在遍历过程中不停调用 pop 方法，把返回值放入一个新数组中就可以了。

```c
void heapSort(int* arr, int length) {
  Heap* heap = createHeap(arr, length);
  for (int i = 0; i < length; i++) {
    arr[i] = pop(heap);
  }
  freeHeap(heap);
}
```

但是这个版本的问题在于：

1. 需要额外创建一个堆结构来存储数据；
2. 每次 pop 操作实际上都会重新调整堆，增加了不必要的开销。

我们知道，堆本质上就是一个数组，所以我们可以直接对原数组进行堆化操作，原地排序。

#### 建堆

根据堆的实现，调整堆的思路有两种：

1. 入队时对新入队的元素上浮，自下而上调整，每次比对当前节点与父节点的大小。
2. 出队后从根节点开始下沉，自上而下调整，每次比对当前节点与其左右子节点的大小。

我们需要把一个无序数组构建成一个堆，也可以选择这两种思路。

##### 自下而上

```c
void heapify(int* arr, int length) {
  for (int i = 0; i < length; i++) {
    siftUp(arr, i);
  }
}
```

很明显，与乞丐版本的逻辑类似，遍历整个数组，对每个元素进行 O(logn) 级别的调整，所以时间复杂度为 O(nlogn)。

##### 自上而下

```c
void heapify(int* arr, int length) {
  for (int i = length / 2 - 1; i >= 0; i--) {
    siftDown(arr, length, i);
  }
}
```

但是如果我们使用自上而下的方式，因为叶子节点不需要调整，我们只需要从最后一个非叶子节点开始，倒序遍历到根节点，对每个节点进行下沉操作即可。

**其中，最后一个非叶子结点是最后一个元素的父节点，即 `(length - 1 - 1) / 2`，简化一下就是 `length / 2 - 1`。**

在一棵树中，叶子节点的数量大约会占到整个树的一半，所以我们这里只需要遍历一半的节点。

同时，虽然理论上单个节点的下沉操作最坏是 O(logn)，但由于树的性质，大多数节点都在树的下半部分，它们下沉的距离很短，需要完整下沉的节点数量很少，只有堆顶元素才需要下沉 O(logn) 的距离。

这种不均匀的操作分布使得这个版本的 heapify 复杂度降到了 O(n) 级别。

#### 堆排序

有了以上的堆化操作，我们就可以进行堆排序了。

```c
void heapSort(int* arr, int length) {
    // 从最后一个非叶子节点开始，自上而下调整堆
    for (int i = length / 2 - 1; i >= 0; i--) {
        siftDown(arr, length, i);
    }
    // 排序
    for (int i = length - 1; i > 0; i--) {
        // 将堆顶元素与末尾元素交换
        swap(arr, 0, i);
        // 排除掉末尾元素，将剩下的元素重新构建成最大堆
        siftDown(arr, i, 0);
    }
}
```

### 优化

这里我们还可以通过下沉操作来提升性能。

现在的下沉操作会进行大量的交换操作，我们可以通过一个临时变量来减少交换操作，从而提升性能。

```c
static void sink(int* arr, int n, int i) {
    int temp = arr[i];  // 保存当前节点值
    // 沿着较大的子节点向下筛选
    for (int j = 2 * i + 1; j < n; j = 2 * j + 1) {
        // 找到较大的子节点
        if (j + 1 < n && arr[j] < arr[j + 1]) j++;
        // 如果当前值已经大于子节点，结束筛选
        if (temp >= arr[j]) break;
        // 将找到的更大的子节点上移
        arr[i] = arr[j];
        // 继续下沉
        i = j;
    }
    arr[i] = temp;  // 放入最终位置
}
```

这里的优化思路实际上是：

1. 下沉操作时，先保存当前节点值；
2. 沿着较大的子节点向下筛选，如果当前值大于子节点，则停止下沉；
3. 如果当前值小于子节点，则将子节点上移，继续下沉；
4. 最后将当前节点值放入最终位置。

这个思路与插入排序的思路类似，在比较的过程中，通过移动元素来减少交换次数，从而提升性能。