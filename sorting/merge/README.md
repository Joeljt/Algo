## 归并排序

归并排序是一种基于分治法的 $O(n\log n)$ 时间复杂度的排序算法，它是一种稳定的排序算法，适用于大量数据的排序。

### 思路

归并排序的基本思想是将数组拆分为两个子数组，然后递归向下对子数组进行归并排序，直到子数组只剩一个元素，只有一个元素的子数组是有序的。然后在将子数组合并成一个有序的数组的过程中完成整个数组的排序。

由于每次都是将数组拆分为两个子数组，所以整个递归树的深度是 $log_2 n$；每层递归在合并子数组的过程中都会遍历子数组，遍历次数从底向上递增，最后一层递归只需要遍历一个元素，最顶部递归需要遍历 $n$ 次。

因此整个归并排序的时间复杂度为 $O(n \log n)$。

### 实现（divide and conquer）

```c
void merge_sort(int *arr, int n) {
  merge_sort(arr, 0, n - 1);
}

void merge_sort(int *arr, int l, int r) {
  // 使用插入排序优化，在子数组小于等于 15 的时候，使用插入排序
  // 插入排序虽然是 O(n^2) 的时间复杂度，但是数据量小的时候其常数项更小，可以作为高级排序的优化手段使用
  // 这个处理不只是针对大数组，而是作用于每个子数组的，相当于每个递归到底层的子数组，在数据量 <= 15 时，都会使用插入排序而非归并排序
  if (r - l <= 15) {
    insert_sort(arr, l, r);
    return;
  }

  // 递归终止条件：如果左右指针重合，说明子数组只剩一个元素
  if (l >= r) return;
  // 找到中间位置，拆分子数组，l + (r - l) / 2 的写法是为了避免整数溢出
  int mid = l + (r - l) / 2;

  // 递归处理左右两个子数组
  merge_sort(arr, l, mid);
  merge_sort(arr, mid + 1, r);

  // arr[mid] < arr[mid + 1] 时说明整个数据已经有序，可以直接跳过 merge 过程
  if (arr[mid] > arr[mid + 1]) {
    // 合并子数组
    // 执行到这里的时候，l 和 r 不可能是相等的，一定存在两个子数组可以合并
    merge(arr, l, mid, r);
  }
}

void merge(int *arr, int l, int mid, int r) {
  // 需要使用一个临时数组来存储合并后的结果，大小就是当前这一轮的左右子数组的和
  int temp[r - l + 1];
  // 三个指针，一个是左子数组的指针，一个是右子数组的指针，一个是临时数组的指针
  int i = l, j = mid + 1, k = 0;
  // 依次比较左右子数组的元素，将较小的元素放入临时数组，并维护对应的指针
  while (i <= mid && j <= r) {
    if (arr[i] <= arr[j]) {
      temp[k++] = arr[i++];
    } else {
      temp[k++] = arr[j++];
    }
  }

  // 左右子数组容量不一定是相等的，可能只有一个子数组剩余，需要将剩余的元素全部放入临时数组
  while (i <= mid) arr[k++] = arr[i++];
  while (j <= r) arr[k++] = arr[j++];

  // 将临时数组的元素复制回原数组，但是要注意这里有 l 个元素的偏移
  // 因为当前是在合并 [l, r] 这个区间的子数组，所以对应到原数组来说，这个区间的起始位置是 l
  for (int i = 0; i < r - l + 1; i++) {
    arr[i + l] = temp[i];
  }
}
```

递归版本的归并排序比较好理解，核心就是分治后合并，处理好左右子数组，理解 merge 函数的逻辑即可。

这个版本有几个问题可以优化:

1. 数组数量少于 15 时，使用插入排序;
2. arr[mid] < arr[mid + 1] 时说明整个数据已经有序，可以直接跳过 merge 过程;
3. 单独声明一个 temp 数组并传入 merge 函数，优化内存空间，避免频繁申请释放内存。

### 实现（iterative）

除了递归版本，还能使用迭代版本实现归并排序。

不同于归并排序自顶向下层层拆分，而是自底向上，直接尝试对数组进行合并的过程，合并过程就是排序过程。

#### 基本思路

但是自顶向下的归并排序已经有了明确的子数组范围，但是自顶向上合并的过程中，我们是没有这个范围的，所以需要在逻辑层对这个范围进行划分：

1. 先把每个元素当作一个子数组，然后两两进行合并;
2. 合并完成后，每个子数组的范围就是原来的两倍，然后重复这个两两合并的过程，直到合并的子数组的范围大于等于原数组的范围;

#### 外层循环

在这个基础上，我们就可以确定外层循环要做的事情了，即确定两两合并的次数，每次递增两倍，直到超过原数组大小：

```c
for (int size = 1; size <= n - 1; size = size * 2) 
```

#### 内层循环

然后在内层循环中，我们就需要具体确认每次的合并情况，重点也就是确认两个子数组的起始范围：

```c
for (int left = 0; left + size <= n - 1; left = left + size * 2)
```

1. 两个字数组的索引范围分别是 [0, size - 1] 和 [size, size * 2 - 1];
2. 每轮合并都从 0 开始，每次横跨两个 size 长度的子数组;
3. 两个字数组的划分不一定均匀，但是只要两个子数组都有内容，也就是 left + size <= n - 1，就需要处理合并;

用长度为7的数组举例，我们一步步看它是如何排序的：

size = 1 时：
- [0] 和 [1] 合并
- [2] 和 [3] 合并
- [4] 和 [5] 合并
- [6] (单个元素，已经是有序的) 结果：每两个相邻元素都排好序了

size = 2 时：
- [0,1] 和 [2,3] 合并成有序的[0,1,2,3]
- [4,5] 和 [6] 合并成有序的[4,5,6] 结果：现在我们有两个更大的有序段：[0,1,2,3] 和 [4,5,6]

size = 4 时：
- 当 left = 0，条件满足（0 + 4 ≤ 6），所以[0,1,2,3]和[4,5,6]会合并
- 当 left = 8，条件不满足（8 + 4 > 6），循环结束 但这没关系，因为整个数组已经在上一步合并成一个有序序列了！

关键在于，每一轮 size 的增加，都是在前一轮已经排好序的子数据基础上进行合并。当某些元素因为终止条件无法成为左子数组时，它们已经在之前的轮次中被正确合并到某个有序序列中了。

#### 子数组起始位置

在明确了两层循环的定义后，我们还需要确认两个子数组的起始位置：

```c
int mid = left + size - 1;
int right = MIN(left + size * 2 - 1, len - 1);
```

- left 是确定的，每次从 0 开始，按 2*size 进行递增，每次跳过两组子数组；
- mid 就是从 left 开始偏移 size 个元素，所以 mid = left + size - 1;
- right 是右子数组的末尾位置，正常应该是 left + size * 2 - 1，但是可能会越界，所以需要和数组长度取最小值;

之后，利用这些信息，就可以确定每次合并的范围了：[left, mid] 和 [mid + 1, right]，然后进行合并即可。

#### 完整代码

完整代码实现如下：

```c
void merge_sort(int* arr, int len) {
  for (int size = 1; size <= len - 1; size = size * 2) {
    for (int left = 0; left + size <= len - 1; left = left + size * 2) {
      int mid = left + size - 1;
      int right = MIN(left + size * 2 - 1, len - 1);
      if (arr[mid] > arr[mid + 1]) {
        merge(arr, left, mid, right);
      }
    }
  }
}
```

### 应用

- 给定两个有序数组，合并成一个有序数组
- 寻找数组中的逆序对数量

