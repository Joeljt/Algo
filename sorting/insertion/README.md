## 插入排序

插入排序是一种简单的排序算法，与我们打扑克牌时整理牌的方式类似。

与选择排序类似，插入排序也是一个 O(n^2) 的算法。

其基本思想是：

1. 将数组分为已排序和未排序两个区间；
2. 对未排序区间的元素逐个进行遍历，然后将之与已排序区间的值一一对比，尝试寻找其应在的位置；
3. 如果没有找到其应在的位置，就继续向前，同时将所有元素向后移动一位，为当前元素腾出空间；
4. 重复上述过程，直到：
    - 当前元素已找到其应在的位置；
    - 当前元素已到达数组头部；
5. 将当前元素插入到对应位置（要么是其应该在的位置，要么是数组头部）。

### 特点

- 最好情况：O(n)，即数组已经有序；
- 最坏情况：O(n^2)，即数组完全逆序；
- 平均情况：O(n^2)。
- 稳定：是。

### 实现

```c
void insert_sort(int *arr, int len) {
    // 1
    for (int i = 1; i < len; i++) {
        // 2
        int target = arr[i];
        // 3
        int j = i;
        // 4
        while (j > 0 && arr[j - 1] > target) {
            // 5
            arr[j] = arr[j - 1];
            // 6
            j--;
        }
        // 7
        arr[j] = target;
    }
}
```

### 注意点

1. 外层循环从 1 开始，因为元素 0 默认已排序；
2. 把当前正在检查的元素提前存下来，因为后面向前比较的时候会用前面的元素把当前元素覆盖掉；
3. 内层循环从当前位置开始，回头向前比较；
4. 如果前一个元素比当前正在检查的这个元素，namely 未排序列表的第一个元素，还要大，就说明当前这个元素应该向前继续匹配；
5. 这种情况下，就把前一个元素往后移动一位，给当前正在检查的这个元素腾出来位置；
6. j-- 继续向前匹配；
7. 走到这一步时循环已经结束，有两种可能：
   1. 找到了目标位置，不再满足 arr[j - 1] > target 的条件，此时 j 指向目标位置；
   2. 未找到目标位置，不再满足 j > 0 的条件，即此时 j 指向 0，也就是说当前检查的元素就是最小值，所有元素都往后移动了一个位置，把 0 的位置让给了它；
   这两种情况下，j 都指向正在检查的元素应该在的位置，直接将目标元素赋值到对应的位置即可。

### 排序流程

假设对 [5, 4, 3, 2, 1] 进行升序排列，整个流程是：

i = 1, target = 4; j = 1
[5, 4, 3, 2, 1] // 起始状态
[5, 5, 3, 2, 1] // 5 > 4，5 向后移动一位，给 target 让出位置
[4, 5, 3, 2, 1] // arr[0] = target，完成插入

i = 2, target = 3, j = 2
[4, 5, 3, 2, 1] // 起始状态
[4, 5, 5, 2, 1] // 5 > 3，5 向后移动一位
[4, 4, 5, 2, 1] // 4 > 3，4 向后移动一位
[3, 5, 3, 2, 1] // arr[0] = target，完成插入

i = 3, target = 2, j = 3
[3, 4, 5, 2, 1] // 起始状态
[3, 4, 5, 5, 1] // 5 > 2，5 向后移动一位
[3, 4, 4, 5, 1] // 4 > 2，4 向后移动一位
[3, 3, 4, 5, 1] // 3 > 2，3 向后移动一位
[2, 3, 4, 5, 1] // arr[0] = target，完成插入

i = 4, target = 1, j = 4
[2, 3, 4, 5, 1] // 起始状态
[2, 3, 4, 5, 5] // 5 > 1, 5 向后移动一位
[2, 3, 4, 4, 5] // 4 > 1, 4 向后移动一位
[2, 3, 3, 4, 5] // 3 > 1, 3 向后移动一位 
[2, 2, 3, 4, 5] // 2 > 1, 2 向后移动一位 
[1, 2, 3, 4, 5] // arr[0] = target，完成插入

循环结束的同时也完成了排序。