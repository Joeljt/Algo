## 希尔排序

插入排序的逻辑是：每次从未排序的部分中选择一个元素,然后将其插入到已排序的部分中的合适位置，时间复杂度是 $O(n^2)$。

但是如果数据本身有序，即每个元素都在它应该在的位置上，那插入排序的内层循环完全不会执行，只是扫描了一遍整个数组，所以插入排序的时间复杂度会变成 $O(n)$。即使数据不是完全有序，但是逆序对的数量很少，插入排序的效率也会相应的提高，因为逆序对越少，内层循环的执行次数就越少。

希尔排序正是利用这个特性对插入排序进行了优化。

1. 按照不同的步长将数组分成若干个子数组，然后对每个子数组进行插入排序;
2. 步长按规律进行递减，直到步长为 1 时，相当于对整个数组执行了一遍插入排序，从而完全整个排序工作。
3. 不同的步长序列会导致希尔排序不同的时间复杂度。

### 特点

希尔排序通过步长分组实现了跳跃式的比较和移动：

1. 初始步长较大，能够快速将小元素前移、大元素后移，避免了插入排序的一步一步移动;
2. 步长逐渐减小的时候，是在处理中等距离的逆序对，每次排序都在优化数组的局部有序性;
3. 最后一轮实际上是在几乎有序的数组上进行插入排序，时间复杂度几乎可以看作 $O(n)$。

希尔排序的设计看似增加了一重循环，但是这重循环的过程中不停地在减少逆序对的数量，让每次额外的插入排序实际上都是以几乎 $O(n)$ 的时间完成的。

### 实现

```c
void shell_sort(int *arr, int len) {
  // 1
  int gap = len / 2;
  // 2
  while (gap >= 1) {
    // 3
    for (int i = gap; i < len; i++) {
      int target = arr[i];
      int j = i;
      // 5
      while (j >= gap && arr[j - gap] > target) {
        arr[j]= arr[j - gap];
        j -= gap;
      }
      arr[j] = target;
    }
    // 4
    gap /= 2;
  }
}
```

### 注意点

1. 不同的步长序列会影响希尔排序的时间复杂度，以数组长度的 1/2 为初始步长适合理解算法思想;
2. 步长最小需要到 1，之后再进行一轮完整的插入排序即可完成排序;
3. 步长循环内部就是一个完整的插入排序，只不过将默认的 1 变成了当前步长值，**当 gap = 1 时，就是插入排序**;
4. 步长每次减半，直到最后一轮 1/2=0 之后结束循环，完成排序;

### 排序流程

以数组 [8, 9, 1, 7, 2, 3, 5, 4, 6, 0] 为例，采用 gap = length/2 的步长序列：

1. 初始 gap = 5：
   - 比较 [8, 9, 1, 7, 2 | 3, 5, 4, 6, 0]
   - 8与3比较，9与5比较，1与4比较，7与6比较，2与0比较
   - 变成：[3, 5, 1, 6, 0 | 8, 9, 4, 7, 2]

2. gap = 2：
   - 比较 [3, 5 | 1, 6 | 0, 8 | 9, 4 | 7, 2]
   - 进一步优化局部有序性
   - 变成：[1, 2, 3, 4, 0, 5, 7, 6, 9, 8]

3. 最后 gap = 1：
   - 普通插入排序
   - 但此时逆序对已经很少
   - 最终完成排序：[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

可以看到每一步都在优化数组的局部有序性，最后一步实际上工作量很小。

### 步长选择

如前所述，不同的步长选择会影响希尔排序的时间复杂度。

```c
void shellSort2(int* arr, int length) {
  int gap = 1;
  while (gap < length)
    gap = 3 * gap + 1;

  while (gap >= 1) {
    // insertion sort
    gap /= 3;
  }
}
```

注意上面代码中对步长的处理：

1. 初始步长为 1，然后将步长按照 3*n+1 的规律递增;
2. 具体对 gap 进行递减的时候，每次除以 3 即可。
