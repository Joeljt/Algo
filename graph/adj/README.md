## 图论

图论要解决的问题，简单来说就是连接问题，即两个节点（顶点）之间是否存在连接（边或路径）。

通过将真实生活中的场景抽象建模为图中的顶点和边，通过添加边的方向、权重等信息，在对图的遍历过程中实现一系列操作，并解决期望解决的问题。

术语：

- 邻接表
- 邻接矩阵
- 顶点
- 边
- 度
- 权
- 向
- 桥
- 割
- 连通分量
- 同构图
- 平面图

### 基本表示

图主要解决的是连接性问题，即如何有效表达各个节点是否有连接关系，又是如何连接的。

具体而言，图有两种基本的表达方式：邻接矩阵和邻接表。

#### 邻接矩阵


### 深度优先遍历

图的遍历与二叉树的遍历在结构上是完全一样的，只不过由于图的特点，在两方面有所不同：

- 因为图的顶点之间是相互联通的，所以在遍历的时候有可能会重复访问同一顶点，因此需要维护一个 `visited` 数组，来记录是否访问过，如果已经访问过就跳过，避免重复访问；

- 因为图不像二叉树那样可以严格地分成左右子树，从而展开递归，而是有多个顶点，每个顶点都连接其他顶点，因为需要遍历每个顶点的相邻顶点，依次递归遍历

几乎所有问题实际上都是遍历的问题，因为想解决某个问题，必须完整地访问一遍所有顶点。

在遍历的过程中，或额外记录某些信息，或通过增加返回值改变递归函数的语义，就可以对不同的问题求解。

- 求图中的联通分量个数
    - 遍历时记录联通分量的 id 信息，改变 visited 数组的定义，将 visited 数组转化为并查集，可以有效地确定两个不同的顶点是否在同一联通分量中

- 单源路径求解
    - 遍历时记录 pre 数组，记录当前顶点的遍历是作为哪个顶点的相邻顶点过来的，将该顶点记为 parent 顶点，然后通过访问 pre 数组就可以算出任一顶点到另一顶点的路径信息
    - 注意这里记录的路径只是随便一条路径，与边的添加逻辑有关，而不是最短路径

- 检测图中是否存在环
    - 与路径问题类似，在遍历时记录当前顶点的 parent 顶点，当遍历到某个顶点，发现该顶点已经被访问过，但是本次遍历又不是由 parent 顶点出发的，则判断存在环
    - 通过给 dfs 函数增加返回值，改变函数语义为【从当前顶点出发遍历，是否能够回到当前顶点】，可以在检测到环之后立即终止遍历过程，提高效率

- 二分图检测
    - 将图中所有的顶点分为两部分，图中每条边两侧连接的顶点都属于不同的部分，即判定为二分图。
    - 通过在遍历的过程中对每个节点进行染色，保证相邻顶点与当前顶点的颜色不同，同时在递归过程中检查颜色冲突，从而可以有效判断是否是二分图。
    - 与环检测类似，通过给 dfs 函数增加返回值，改变函数语义为【当前顶点与所有相邻顶点是否颜色都不相同】，从而实现颜色冲突的判定逻辑。

### 广度优先遍历

和深度优先遍历一样，图的广度优先遍历也与树的广度优先遍历逻辑完全相同。

借助队列，将某个顶点先入队，之后将与该顶点相连的所有顶点依次入队，同时在过程中注意维护 visited 的信息。

由于广度优先遍历会扫描所有相连顶点并将其依次入队，所以在遍历的过程中，BFS 可以保证到达每个顶点的路径一定是最短的：

每次都会把离顶点更近的那一层逐一入队后再逐一访问，即使有某个顶点被多个顶点相连，只要有一个更上层的顶点与之相连，就能保证在遍历到该上层顶点时，直接查询到该顶点，从而保证该顶点会以高层顶点的相连点被更早的访问到，等遍历到低层顶点的时候，会发现该顶点已经被访问过了。

举例来说，0-2-3-6 / 0-1-5-3-4

顶点 3 的前驱顶点有 2 和 5 两个顶点，但是广度优先遍历的时候，会：

1. 先入队 0，然后访问 0 的时候，入队与 0 相连的顶点 1 和 2；
2. 访问 1 的时候入队 5，访问 2 的时候入队 3；
3. 目前队列中有 5 和 3，访问 5 的时候入队 3，访问 3 的时候入队 6；

到这个时候，3 就已经作为 2 的子顶点被访问过了，等下一轮循环访问到 3 的时候，会发现 3 已经被访问过了。

所以，在这种层序遍历的情况下，能保证**从遍历顶点到某一点之间**的路径一定是最短的。

