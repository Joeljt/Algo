## 图的基本表示和遍历

图主要解决的是连接性问题，即如何有效表达各个节点是否有连接关系，又是如何连接的。

一般来说，我们习惯用 V 来表示图中的顶点数，用 E 来表示图中的边数。

具体而言，图有两种基本的表达方式：邻接矩阵和邻接表。

### 邻接矩阵

邻接矩阵实际上就是使用二维数组来表示顶点之间的关系。

对于图中的每一个顶点，都有一个数组用来维护从该顶点出发到其他顶点是否有边，也就是说 [0][0] 表示顶点 0 到顶点 0 是否有边连接，[0][1] 表示顶点 0 到顶点 1 是否有边连接，以此类推。

所以，邻接矩阵一定是一个 V*V 的二维矩阵，一维数组是所有的顶点信息，二维数组表示的具体的顶点到其他各顶点的连通性。

邻接矩阵表示的图比较好理解，但是缺点在于无论对应的顶点是否有连通，都需要开辟对应的数组空间，这对于稀疏图来说是很浪费空间资源的。

比如，一个有 5 个顶点的图，每个顶点只和其他一个顶点相连，在这种情况下，25 个矩阵元素中，只有 5 个元素的值是真正有价值的。

相对应的，邻接矩阵更适合稠密图，即每个顶点都和其他所有顶点相连接。这种情况下，一定需要 V*V 的二维矩阵，也就没有浪费的情况了。

```c
void mg_addEdge(MatrixGraph* graph, int a, int b) {
  assert((a >= 0 && a < graph->V) && (b >= 0 && b < graph->V));
  if (graph->adj[a][b] == 0) {
    // 无向图，两个节点相对于对方都需要标记连接
    graph->adj[a][b] = 1;
    graph->adj[b][a] = 1;
    // 维护 E
    graph->E++;
  }
}

// 查找顶点 v 在图中所有相连的顶点
AdjMatrix mg_adj(MatrixGraph* graph, int v) {
  assert(v >= 0 && v < graph->V);
  // 初始化一个结构，用来记录存储的相连节点列表和数量信息
  AdjMatrix result = {NULL, 0};

  // 初始化临时数组，顶点数量最大不可能超过总节点数量
  int* temp = (int*)malloc(sizeof(int) * graph->V);
  int index = 0;
  for (int i = 0; i < graph->V; i++) {
    // 在当前顶点的连接表中查找连接的顶点，并将其放到数组中记录下来
    if (graph->adj[v][i] == 1) {
      temp[index] = i;
      index++;
    }
  }
  // 将返回的列表重新调整为实际的大小
  result.neighbours = (int*)realloc(temp, index * sizeof(int));
  result.count = index;
  return result;
}
```

### 邻接表

邻接矩阵在稀疏图场景下对空间利用效率不高，这种情况下使用邻接表可以较好的利用空间。

图的本质就是各顶点之间的表示关系，邻接表的实现实际上是基于链表的。

因为图是一系列顶点的集合，所以一维数组是一定会有的，用来存储各个顶点与其他顶点的联通状态。

但是不同于邻接矩阵需要提前开好 V 个空间，用来存储可能的连接状态，链表结构只需要按需声明节点并链接起来即可。

正如邻接表这个名字本身所表示的一样，这个版本的表示实际上与哈希表异曲同工，也是数组+链表的搭配。

```c
void lg_addEdge(ListGraph* graph, int a, int b) {
  assert((a >= 0 && a < graph->V) && (b >= 0 && b < graph->V));

  VertexNode* newNode = NULL;

  // 添加边 a -> b
  newNode = createVertexNode(b);     // 新建一个存储了 b 顶点信息的链表节点
  newNode->next = graph->adj[a];  // 把这个新节点插入到 graph->adj[a] 这个链表的链表头
  graph->adj[a] = newNode;        // 更新 graph->adj[a] 链表为最新的链表头

  // 添加边 b -> a
  newNode = createVertexNode(a);     // 新建一个存储了 a 顶点信息的链表节点 
  newNode->next = graph->adj[b];  // 让这个新链表指向 graph->adj[b] 的链表，成为该链表的头节点
  graph->adj[b] = newNode;        // 更新 graph->adj[b] 存储的链表为最新的链表头

  graph->E++;
}

// 获取与顶点 v 相连接的所有顶点信息
AdjList lg_adj(ListGraph* graph, int v){
  assert(v >= 0 && v < graph->V);

  AdjList result = { NULL, 0 };

  int* temp = (int*)malloc(graph->V * sizeof(int));
  int index = 0;

  // 从当前节点存储的第一个节点开始遍历
  VertexNode* current = graph->adj[v];
  while (current != NULL) {
    // 因为链表只会存储真正连接的顶点，所以不需要判断，直接赋值即可
    temp[index] = current->vertex;
    index++;
    current = current->next;
  }

  // 调整最终的相邻节点数据
  result.neighbours = (int*)realloc(temp, index * sizeof(int));
  result.count = index;

  return result;
}
```

## 图的遍历

### 深度优先遍历

图的遍历与二叉树的遍历在结构上是完全一样的，只不过由于图的特点，在两方面有所不同：

- 因为图的顶点之间是相互联通的，所以在遍历的时候有可能会重复访问同一顶点，因此需要维护一个 `visited` 数组，来记录是否访问过，如果已经访问过就跳过，避免重复访问；

- 因为图不像二叉树那样可以严格地分成左右子树，从而展开递归，而是有多个顶点，每个顶点都连接其他顶点，因为需要遍历每个顶点的相邻顶点，依次递归遍历

几乎所有问题实际上都是遍历的问题，因为想解决某个问题，必须完整地访问一遍所有顶点。

在遍历的过程中，或额外记录某些信息，或通过增加返回值改变递归函数的语义，就可以对不同的问题求解。

- 求图中的联通分量个数
    - 遍历时记录联通分量的 id 信息，改变 visited 数组的定义，将 visited 数组转化为并查集，可以有效地确定两个不同的顶点是否在同一联通分量中

- 单源路径求解
    - 遍历时记录 pre 数组，记录当前顶点的遍历是作为哪个顶点的相邻顶点过来的，将该顶点记为 parent 顶点，然后通过访问 pre 数组就可以算出任一顶点到另一顶点的路径信息
    - 注意这里记录的路径只是随便一条路径，与边的添加逻辑有关，而不是最短路径

- 检测图中是否存在环
    - 与路径问题类似，在遍历时记录当前顶点的 parent 顶点，当遍历到某个顶点，发现该顶点已经被访问过，但是本次遍历又不是由 parent 顶点出发的，则判断存在环
    - 通过给 dfs 函数增加返回值，改变函数语义为【从当前顶点出发遍历，是否能够回到当前顶点】，可以在检测到环之后立即终止遍历过程，提高效率

- 二分图检测
    - 将图中所有的顶点分为两部分，图中每条边两侧连接的顶点都属于不同的部分，即判定为二分图。
    - 通过在遍历的过程中对每个节点进行染色，保证相邻顶点与当前顶点的颜色不同，同时在递归过程中检查颜色冲突，从而可以有效判断是否是二分图。
    - 与环检测类似，通过给 dfs 函数增加返回值，改变函数语义为【当前顶点与所有相邻顶点是否颜色都不相同】，从而实现颜色冲突的判定逻辑。

### 广度优先遍历

和深度优先遍历一样，图的广度优先遍历也与树的广度优先遍历逻辑完全相同。

借助队列，将某个顶点先入队，之后将与该顶点相连的所有顶点依次入队，同时在过程中注意维护 visited 的信息。

由于广度优先遍历会扫描所有相连顶点并将其依次入队，所以在遍历的过程中，BFS 可以保证到达每个顶点的路径一定是最短的：

每次都会把离顶点更近的那一层逐一入队后再逐一访问，即使有某个顶点被多个顶点相连，只要有一个更上层的顶点与之相连，就能保证在遍历到该上层顶点时，直接查询到该顶点，从而保证该顶点会以高层顶点的相连点被更早的访问到，等遍历到低层顶点的时候，会发现该顶点已经被访问过了。

举例来说，0-2-3-6 / 0-1-5-3-4

顶点 3 的前驱顶点有 2 和 5 两个顶点，但是广度优先遍历的时候，会：

1. 先入队 0，然后访问 0 的时候，入队与 0 相连的顶点 1 和 2；
2. 访问 1 的时候入队 5，访问 2 的时候入队 3；
3. 目前队列中有 5 和 3，访问 5 的时候入队 3，访问 3 的时候入队 6；

到这个时候，3 就已经作为 2 的子顶点被访问过了，等下一轮循环访问到 3 的时候，会发现 3 已经被访问过了。

所以，在这种层序遍历的情况下，能保证**从遍历顶点到某一点之间**的路径一定是最短的。