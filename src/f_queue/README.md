## 队列

队列是一种线性数据结构，类似生活中的排队，先进先出。

核心操作以及时间复杂度：
- `enqueue(E e)`：入队，O(1)
- `dequeue()`：出队，数组队列 O(n)，循环队列 O(1)
- `getFront()`：获取队首元素，O(1)
- `isEmpty()`：判断队列是否为空，O(1)
- `getSize()`：获取队列中元素个数，O(1)

### 数组队列

基于数组实现的队列比较好理解，从数组末尾入队（addLast），从数组开头出队（removeFirst）。

但是数组的 `removeFirst` 操作需要把数组中所有元素向前移动一位，所以时间复杂度为 O(n)，需要使用循环队列来优化。

### 循环队列

由于数组队列的 `dequeue` 操作时间复杂度为 O(n)，所以需要使用循环队列来优化。

核心思路是：
- 单独维护队首队尾下标，`front` 指向队首元素，`tail` 指向队尾元素的下一个元素
- `front` 和 `tail` 的自增操作都需要增加 `%` 取余操作，从而实现循环

#### 实现方案

1. 主动浪费一个空间，完全依赖 `front` 和 `tail` 的相对位置关系来判断队列状态：

    - 当 `front` 和 `tail` 相等时，表示队列为空
    - `tail` 向前再进一步如果与 `front` 相等，表示队列为满 （`(tail+1) % length == front`）
    - `tail` > `front` 时，说明队列顺序正常，队列元素个数为：`tail` - `front`
    - `tail` < `front` 时，说明队列处于循环状态，队列元素个数为：`len` - `front` + `tail`

2. 不浪费空间，但是需要自己维护队列元素个数（逻辑更简单）

    - `size` 为 0 时队列为空，`size` == `len` 时队列为满

#### 遍历

1. 每个元素都有 `front` 个位置的偏移：

```java
for (int i = 0; i < size; i++) {
    E e = data[(i + front) % length];
}
```

2. 从 `front` 开始向后依次遍历：


```java
for (int i = front; i != tail; i = (i + 1) % length) {
    E e = data[i];
}
```

### 双端队列

双端队列不同于普通的队列，同时支持在队列首尾进行元素的插入和删除，过程中需要注意边界值的处理。

#### 核心思路

1. `addLast` 与 `removeFirst` 分别对应普通队列的入队和出队操作，没有任何区别，无需过分关注；

2. `addFirst` 与 `removeLast` 与标准的入队出队相反，需要格外注意临近值；
  - `addFirst` 需要在队首添加元素，需要注意 `front` 的值需要递减，并在到达 `0` 时循环回到数组尾；
  - `removeLast` 同理，从队尾删除元素时，需要回退 `tail` 变量的值，谨慎处理 `0` 的场景；

核心还是依赖 `%` 运算：

- 在标准实现里，下标只会递增并且大于 0，`index % len` 即可循环到队列头，确保值永远处于 `[0, len - 1]` 这个区间内；

- 在双端队列中，下标有可能会变成 `-1`，需要小心处理：

    1. `front == 0 ? len + 1 : front - 1` 特殊判断临界点，然后手动矫正是可以满足需求的；

    2. `(front - 1 + len) % len` 是一个更通用的公式: 
        - 如果 `front` > 0，（n + 10） / 10 的余数还是 n，值不会发生改变；
        - 如果 `front` 等于 0，那这个公式可以实现倒退回数组末尾的效果，也正是我们需要的；

#### 优化方向

假设队列的排列为：`[1, 2, 3, 4, 5, null]`, 这种情况下调用 `addFirst` 进行入队操作，由于队列已满会优先进行扩容。扩容后队列的情况为：`1, 2, 3, 4, 5, null, null, null, null, null, null`。

然后继续调用 `addFirst(-1)` 进行插入，经过 `(front - 1 + len) % len` 的矫正操作以后，`front` 会定位到数组最后一位：

`1, 2, 3, 4, 5, null, null, null, null, null, -1`

此时，一个刚刚扩容完成的队列转化为了循环队列，这种情况下，由于数组元素的位置不连续，对命中 CPU 缓存不友好，可以考虑如下优化方案：

在扩容时，主动将队列放在队列的中间位置，保证前后都有空间进行插入。

```java
private void resize(int newCapacity) {
    E[] newData = (E[])new Object[newCapacity];
    
    // 计算新数组中的起始位置
    int start = (newCapacity - size) / 2;
    int j = start;
    
    // 从 front 开始，复制 size 个元素
    for (int i = 0; i < size; i++) {
        // 通过取模来处理循环的情况
        newData[j++] = data[(front + i) % data.length];
    }
    
    // 更新索引
    front = start;
    tail = j;
    
    data = newData;
}
```

这样扩容完以后的数组：`[null, null, -1, 1, 2, 3, 4, 5, null, null]`，从而保证队列前后都有空间可以插入新元素。

### `%` vs `&`

在 Java 的 `Deque` 实现中，使用 `&` 代替了 `%` 操作，从而实现了更高效的索引定位能力。

当数组总长度为 2 的幂时，`n & (len - 1)`等价于 `n % len`。

`n % len` 的本质是求 `n` 除以 `len` 的余数，比如 9 / 8 商 1 余 1，而余数永远不可能大于被除数，余数的最大值就是（被除数 - 1）。

当数组总长度为 2 的幂时，以 8 举例说明，8 的二进制表示为 0000 1000，即最高位为 1，之后的低位全部为 0。

在这种情况下，`len - 1` 也就是 7 的二进制表示为： 0000 0111，即原本高位的 1 减掉以后，后面所有的 0 都会变为 1。

同时，我们知道 `&` 的含义是，只有双方都为 1,最后结果才为 1,否则结果就是 0。

如果我们用 9 & (8 - 1)，效果就是 `0000 1001 & 0000 0111`, 最终结果就是 1，与 % 取余数的效果是完全相同的。

通过对 `len` 进行 -1 操作，就得到了 `len` 作为被除数时，余数有可能的最大值。

在这个基础上，用目标值对 (len - 1) 进行 & 操作，利用逻辑与的特性，强制去掉了高位，只保留了低位，保证得到的值就是最终的余数。

只有末尾不足 2 的幂的那部分才会参与运算，所以最后的结果就和取模求余数的结果相同。

```
len = 8     = 1000
len - 1 = 7 = 0111   <- 这就是用来 & 的掩码(mask)，结果一定 <= mask

现在取一个数 n = 11：
11 的二进制       = 1011
& (len-1) = 7    = 0111
结果             = 0011 (3)

验证：
11 ÷ 8 = 1 余 3
11 % 8 = 3
```

#### 性能差异

- 取模运算（%）：需要做除法运算，通常需要 20-50 个 CPU 周期，具体取决于 CPU 架构

- 位运算（&）： 单个 AND 指令，通常只需要 1 个 CPU 周期，几乎所有 CPU 架构都一样快