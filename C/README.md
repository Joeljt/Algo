## C Language Pitfalls

### 指针

```c
/**
 * 注意这个的双指针应用。
 * 
 * 原始参数本来就是指针，是因为对应的对象空间开辟在堆上，上层 caller 栈帧中缓存的只是堆内存的地址值。
 * 当需要访问调用时，也是把那个地址值传到了当前函数里。
 * 
 * 但是，当前函数在执行的时候也会有自己的局部调用栈，会临时开辟变量空间，用来存储传入的参数的值。
 * 在这种情况下： 虽然 head 可以直接访问堆内存的值，但是当给 head 赋值的时候就会失效，因为只是赋值给了一个局部变量，
 * 等当前函数执行完毕，其调用栈内的所有变量都会被回收，刚刚的赋值操作完全影响不到上层 caller 传入的值。
 * 
 * 如果想真实改变传入的参数，就需要传入一个指针，这样栈里声明的变量就不是一个普通的临时变量，而是一个真实的对堆内存的指针。
 * 这时候对指针的修改就会真实作用到堆内存中，真实影响到内存中的数据。
 * 
 * 关键在于函数调用时其栈帧的独立性。每个传入的参数都是当前调用栈内的一个局部变量而已，只有指针才能真正改变堆内存。
 * 
 *  ┌─── main 的栈帧 ───┐
 *  │  list = 0x123    │ ──┐
 *  └──────────────────┘   │
 *                         │    ┌── 堆内存 ──┐
 *                         └───>│ 0x123: [...│
 *                              └────────────┘
 *      ↓ 调用 push
 *      
 *  ┌─── push 的栈帧 ───┐
 *  │  head = 0x123    │ ──┐
 *  │  newNode = 0x456 │   │    ┌── 堆内存 ──┐
 *  └──────────────────┘   └───>│ 0x123: [...│
 *                              │ 0x456: [...│
 *                              └────────────┘
 *      ↓ head = newNode
 *      
 *  ┌─── push 的栈帧 ───┐
 *  │  head = 0x456    │ ──┐
 *  │  newNode = 0x456 │   │    ┌── 堆内存 ──┐
 *  └──────────────────┘   │    │ 0x123: [...│
 *                         └───>│ 0x456: [...│
 *                              └────────────┘
 *      ↓ 函数返回，push 栈帧销毁
 *
 *  ┌─── main 的栈帧 ───┐
 *  │  list = 0x123    │ ──┐
 *  └──────────────────┘   │    ┌── 堆内存 ──┐
 *                         └───>│ 0x123: [...│
 *                              │ 0x456: [...│
 *                              └────────────┘
 * 
 */
int main() {
    Node* list = 0x123;     // main 的栈帧中的变量
    push(list, 1);          // 值 0x123 被复制到 push 的栈帧中
    push(&list, 1);         // 值 0x123 的地址被复制到 push 的栈帧中
    return 0;
}

void push(Node* head, int data) {
    // push 的栈帧
    // head = 0x123 (从 main 中复制来的值)
    Node* newNode = malloc(sizeof(Node));  // 0x456
    head = newNode;   // 修改的是 push 栈帧中的局部变量，main 栈帧中的 list 完全不受影响
} // push 栈帧被销毁，局部变量 head 消失

void push(Node** headRef, int data) {
    // headRef 指向 main 栈帧中 list 的地址
    // 通过 *headRef 可以修改 main 栈帧中的 list
    *headRef = newNode;  // 修改 main 栈帧中的 list
}
```



```c
void push(Node** nodeRef, int data) {
    Node* newData = (Node*)malloc(sizeof(Node));
    newData->data = data;
    // *nodeRef 是取出当前地址所对应的值，然后赋值给 newData->next 
    // 注意取值的动作是一次性的，取完值就结束了，之后的赋值操作和这一步没有关系
    newData->next = *nodeRef;
    // 将 newData 的内容放到 *nodeRef 所在的地址位置
    *nodeRef = newData;
}
```

