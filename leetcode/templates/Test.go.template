package {{name}}

import (
	"fmt"
	"reflect"
	"strings"
)

// æµ‹è¯•ç”¨ä¾‹ç»“æ„ä½“ - æ ¹æ®å…·ä½“é¢˜ç›®è°ƒæ•´å­—æ®µç±»å‹
type TestCase struct {
	input    interface{} // è¾“å…¥å‚æ•°ï¼Œæ ¹æ®é¢˜ç›®è°ƒæ•´ç±»å‹
	expected interface{} // æœŸæœ›è¾“å‡ºï¼Œæ ¹æ®é¢˜ç›®è°ƒæ•´ç±»å‹
	// å¯ä»¥æ·»åŠ æ›´å¤šå­—æ®µï¼Œå¦‚ length, target ç­‰
}

// è¿è¡Œå•ä¸ªæµ‹è¯•ç”¨ä¾‹
func runTest(tc TestCase) bool {
	// TODO: æ ¹æ®å…·ä½“é¢˜ç›®å®ç°æµ‹è¯•é€»è¾‘
	// ç¤ºä¾‹ï¼š
	// result := solution(tc.input)
	// if !reflect.DeepEqual(result, tc.expected) {
	//     fmt.Printf("âŒ æµ‹è¯•å¤±è´¥: è¾“å…¥ %v, æœŸæœ› %v, å¾—åˆ° %v\n", tc.input, tc.expected, result)
	//     return false
	// }
	
	fmt.Printf("âœ… æµ‹è¯•é€šè¿‡: è¾“å…¥ %v, è¾“å‡º %v\n", tc.input, tc.expected)
	return true
}

// è¿è¡Œæ‰€æœ‰æµ‹è¯•ç”¨ä¾‹
func RunTests() {
	fmt.Printf("ğŸ§ª å¼€å§‹æµ‹è¯• LeetCode {{number}}: {{title}}\n")
	fmt.Println(strings.Repeat("=", 60))
	
	// TODO: æ ¹æ®å…·ä½“é¢˜ç›®æ·»åŠ æµ‹è¯•ç”¨ä¾‹
	testCases := []TestCase{
		// ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹ï¼š
		// {
		//     input:    []int{1, 2, 3},
		//     expected: []int{1, 2, 3},
		// },
		// {
		//     input:    []int{},
		//     expected: []int{},
		// },
	}
	
	passed := 0
	total := len(testCases)
	
	for i, tc := range testCases {
		fmt.Printf("\nğŸ“ æµ‹è¯•ç”¨ä¾‹ %d/%d:\n", i+1, total)
		if runTest(tc) {
			passed++
		}
	}
	
	fmt.Println("\n" + strings.Repeat("=", 60))
	fmt.Printf("ğŸ“Š æµ‹è¯•ç»“æœ: %d/%d é€šè¿‡\n", passed, total)
	
	if passed == total {
		fmt.Println("ğŸ‰ æ‰€æœ‰æµ‹è¯•ç”¨ä¾‹éƒ½é€šè¿‡äº†ï¼")
	} else {
		fmt.Println("âš ï¸  æœ‰æµ‹è¯•ç”¨ä¾‹å¤±è´¥ï¼Œè¯·æ£€æŸ¥ä»£ç é€»è¾‘")
	}
}

// ä¸»å‡½æ•°ï¼Œå¯ä»¥ç›´æ¥è¿è¡Œæµ‹è¯•
func main() {
	RunTests()
} 