package e80removeduplicatesfromsortedarrayii

// RemoveDuplicates 删除有序数组中的重复项 II
// LeetCode 80: 给你一个有序数组 nums，请你原地删除重复出现的元素，使得出现次数超过两次的元素只出现两次，返回删除后数组的新长度。
// 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
//
// 示例 1：
//
//	输入：nums = [1,1,1,2,2,3]
//	输出：5, nums = [1,1,2,2,3]
//	解释：函数应返回新长度 length = 5，并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。不需要考虑数组中超出新长度后面的元素。
//
// 示例 2：
//
//	输入：nums = [0,0,1,1,1,1,2,3,3]
//	输出：7, nums = [0,0,1,1,2,3,3]
//	解释：函数应返回新长度 length = 7，并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。
//
// 提示：
//
//	1 <= nums.length <= 3 * 10^4
//	-10^4 <= nums[i] <= 10^4
//	nums 已按升序排列
//
// 思路：
//
//  1. 数组已经是有序的，相同的元素会连续出现
//  2. 使用双指针：快指针遍历原数组，慢指针(writePos) 指向新数组的下一个要写入的位置（也等于新数组的当前大小）
//  3. writePos-1 是新数组的最后一个元素位置，writePos-2 是新数组的倒数第二个元素位置
//  4. 如果当前元素和倒数第二个元素相等（nums[fast] == nums[writePos-2]），
//     由于数组有序，说明新数组中已经有这个元素出现了两次，则不保留
//
// 时间复杂度: O(n)
// 空间复杂度: O(1)
func RemoveDuplicates(nums []int) int {
	// writePos 指向新数组的下一个要写入的位置（也等于新数组的当前大小）
	writePos := 0
	// 快指针遍历原数组
	for i := 0; i < len(nums); i++ {
		// 前两个元素直接保留（writePos < 2），因为无论是否重复都可以保留
		// 从第三个元素开始判断：
		//   - writePos-1 是新数组的最后一个元素位置
		//   - writePos-2 是新数组的倒数第二个元素位置
		//   如果 nums[i] == nums[writePos-2]，由于数组有序，则必有：
		//   nums[writePos-2] == nums[writePos-1] == nums[i]
		//   说明新数组中已经有这个元素出现了两次，不应该再添加
		if writePos < 2 || nums[i] != nums[writePos-2] {
			// 将当前元素写入到新数组的 writePos 位置
			nums[writePos] = nums[i]
			// 写入位置后移，指向下一个要写入的位置
			writePos++
		}
	}
	// 因为下一个写入位置实际上和数组大小是相同的，所以直接返回 writePos 即可
	return writePos
}
