package e88mergesortedarray

// Merge 合并两个有序数组
// LeetCode 88: 给你两个按非递减顺序排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n，分别表示 nums1 和 nums2 中元素的数目。
// 请你将 nums2 合并到 nums1 中，使合并后的数组同样按非递减顺序排列。
//
// 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，
// 其中前 m 个元素表示应合并的元素，后 n 个元素为 0，应忽略。nums2 的长度为 n。
//
// 示例 1：
//
//	输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
//	输出：[1,2,2,3,5,6]
//	解释：需要合并 [1,2,3] 和 [2,5,6]。
//	合并结果是 [1,2,2,3,5,6]，其中斜体加粗标注的为 nums1 中的元素。
//
// 示例 2：
//
//	输入：nums1 = [1], m = 1, nums2 = [], n = 0
//	输出：[1]
//	解释：需要合并 [1] 和 []。
//	合并结果是 [1]。
//
// 示例 3：
//
//	输入：nums1 = [0], m = 0, nums2 = [1], n = 1
//	输出：[1]
//	解释：需要合并的数组是 [] 和 [1]。
//	合并结果是 [1]。
//	注意，因为 m = 0，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。
//
// 提示：
//
//	nums1.length == m + n
//	nums2.length == n
//	0 <= m, n <= 200
//	1 <= m + n <= 200
//	-10^9 <= nums1[i], nums2[j] <= 10^9
//
// 思路提示：
//
//  1. nums1 有足够的空间（m + n）来存储合并后的数组
//  2. 可以从后往前合并，避免覆盖 nums1 中还未处理的元素
//  3. 使用双指针，分别指向 nums1 和 nums2 的末尾，比较后放入 nums1 的末尾
//  4. 思考：如果从前往后合并会有什么问题？为什么从后往前更好？
//
// 时间复杂度: O(m + n)
// 空间复杂度: O(1)
func Merge(nums1 []int, m int, nums2 []int, n int) {

	// nums1 和 nums2 最终需要合并到 nums1 中，nums1 有额外的位置用来承载所有数据
	// 数组本身已经有序，从末尾元素开始倒序向前依次对比两个数组元素，找到更大的那个值放到正确的位置
	// 需要一个额外的指针用来记录结果数组的角标信息，完成插入工作

	// 使用三个指针，分别指向 nums1, nums2, 结果数组的末尾位置
	i, j, k := m-1, n-1, m+n-1

	// 当两个数组都有数据时进行遍历
	for i >= 0 && j >= 0 {
		// 分别比较两个数组的元素，找到更大的那个值，放到目标位置
		if nums1[i] > nums2[j] {
			nums1[k] = nums1[i]
			i--
		} else {
			nums1[k] = nums2[j]
			j--
		}
		// 放好元素后向前移动指针，准备下一次插入
		k--
	}

	// nums1 也可能还有值，但是因为我们是往 nums1 实际上就是结果数组
	// 所以剩下的数据已经在正确的位置上了，不再需要处理
	for i >= 0 {
		nums1[k] = nums1[i]
		i--
		k--
	}

	// nums2 数组可能仍然有值
	for j >= 0 {
		nums1[k] = nums2[j]
		j--
		k--
	}
}
