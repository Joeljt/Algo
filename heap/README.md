## 堆

堆是一种特殊的完全二叉树，堆中每个节点的值都大于等于（或小于等于）其子节点的值。

- 大顶堆：每个节点的值都大于等于其子节点的值
- 小顶堆：每个节点的值都小于等于其子节点的值

堆的本质是数组，只不过逻辑上被表示成了树的形式，在 API 设计上被设计成队列的形式，并且用来处理带有优先级的队列逻辑。

堆是一棵完全二叉树。所谓完全二叉树，就是指树的所有子树的节点都小于父节点，同时所有元素都尽可能靠左侧排列，如果最后一层节点不是满的，那空缺位于右下方。

具体到堆的实现，pop 和 push 的逻辑都很简单，因为堆是数组，所以 pop 就是取出 index 为 0 的位置，push 就是在数组末尾添加元素，并且实时根据数组中的元素数量处理扩容缩容问题。

堆真正麻烦的地方在于如何维护堆的性质，尤其是在出队或者入队元素之后。

使用数组表示树，对于某个元素来说，可以通过某些公式来用该元素的角标去计算出该元素的父节点以及其左右子节点。

假设元素位置为 i，其父节点就是 (i - 1) / 2, 其子节点分别为 2 * i + 1 和 2 * i + 2。

当在数组末尾插入一个新数据的时候，可以将该数据与它的父节点做对比，如果它比父节点还要大，就把它和父节点交换位置（假设我们实现的是一个最大堆），一直循环这个条件，直到把当前元素交换到数组头部，或者某个它应该在的位置，以保证最大堆的性质。

最大堆的性质是，所有的子节点都比它的父节点要小，但是这里不是 BST，左右子节点的大小并不在意，只要满足这个条件即可。

插入的逻辑比较简单，按上面的逻辑即可完成。

如果是出队的话，当前堆里最大堆元素被拿走了，我们需要做某些事情，让这个数组仍然保持最大堆的特性。

所以，在堆顶元素出队后，我们可以将数组末尾的值放到数组第一个位置，这时候肯定不满足最大堆的性质，我们可以自顶向下，将堆顶元素与它的两个字节点进行比较，先比较做左节点（2 * i + 1），再比较右节点（2 * i + 2），哪个值比当前的值更大，就给这两个值交换位置，然后继续向下，直到向下交换到不能交换为止，就说明这个元素走到了它应该在的位置上。

因为是从顶部元素一个一个比较下来的，每次都和子节点都比较过，并且取较大者交换元素，再结合堆作为一棵完全二叉树的特点，父节点比子节点大，所以只要发生了交换，那就一定是更大的节点上去了。

所以走完上面这个步骤，就能保证当前这个数组又重新满足了最大堆的性质，当前的 index 为 0 的元素就又是整个数组里的最大值了。

基本上堆的实现就是这样。本质上是对普通数组实现队列的优化，主要在两个方面，一个是普通数据不涉及排序逻辑，只能按照插入顺序进行出队，先进先出，是标准的队列行为。但是这个堆数组的实现，每次插入后会按照既定的规则和其他数据做对比，通过交换的方式让最大值始终位于数组首位，从而可以保证每次出队的时候都是最大值，而不是固定的入队顺序出队。第二点在于出队后的效率优化，普通的数组出队后队首元素就为空了，如果要保证 data[0] 在下次出队的时候还有值，就必须将后面所有的元素都向前移动一位，这样复杂度就变成了 O(n)，也正是因为这一点，我们才引入了循环数组来优化，不再移动数组，而是移动队首指针。这里堆数组换了一种思路，队首元素出队以后，还是会移动元素把队首元素补上，但是不是死板的 O(n) 移动，而是按照二叉树的方式自顶向下移动，即使最差的结果，可能需要从根节点一直交换移动到叶子节点，但是因为是树结构的比较和移动，最坏情况下的复杂度也是 O(logn) 级别，要远远好过 O(n)。

堆的实现基本就是这样，核心就在于 sift_up 和 sift_down 这两个方法的实现。

### 堆的实现

TODO

### Q&A

#### 完全二叉树的性质决定了它可以用数组来表示，还是想用数组来表示二叉树，才创造了完全二叉树这个概念？

普通的二叉树无论使用递归还是迭代，都很难做到高效地增删改查，所以就想用数组描述一棵树，同时尽可能保证数据的连续性，在这个基础上发现只要二叉树满足除了最后一层以后都是满的，并且叶子结点尽可能的在左子树上，就可以用数组表示一棵二叉树，从而实现 O(1) 的操作复杂度。然后又在这个基础上，规定了一些顺序条件限制，从而额外发展出来堆这个基于用数组表示的二叉树的高级数据结构。

完全二叉树更像是一个为了满足"用数组高效表示"这个需求而设计的概念，它的定义就是为了确保在数组表示时不会有空洞，这种设计反过来为堆这样的数据结构提供了理论基础。

#### 出队时 data[0] 一定是最值吗?

是的，在堆中，data[0] 一定是最值：

- 大顶堆：
  - data[0] 是最大值
  - 因为堆序性要求每个父节点都大于等于其子节点
- 小顶堆：
  - data[0] 是最小值
  - 因为堆序性要求每个父节点都小于等于其子节点

这是堆的一个基本性质，也是为什么堆可以用来实现优先队列的原因。通过 pop 操作，我们总是能在 O(log n) 时间内获取并移除堆顶的最值。

#### 堆是"逻辑上的树，物理上的数组"

```
物理存储（数组）：
[10, 7, 9, 3, 5, 6]

逻辑结构（完全二叉树）：
     10
   /    \
  7      9
 / \    /
3   5  6

索引对应关系：
数组索引：  0  1  2  3  4  5
数组元素： [10,7, 9, 3, 5, 6]
树的层级：  1  2  2  3  3  3
```

堆实际上就是在一个数组里，通过逻辑层的划分构建出来一个逻辑树，在这个树里，因为要尽可能保证数组连续，所以规定完全二叉树的叶子结点尽可能靠左，也就是紧贴着数组元素。

#### 堆的父子节点索引关系

- 父节点索引：`(i-1)/2`
- 左子节点索引：`2i + 1`
- 右子节点索引：`2i + 2`

#### 堆和优先队列

堆关注的始终是最顶部的值，最大还是最小取决于具体的实现，所以本质上堆还是队列。

- 出队（获取并移除堆顶元素）是 O(log n)
- 入队（插入新元素并调整堆）是 O(log n)

普通队列的插入和删除可能是 O(n)（特别是需要保持顺序时），堆通过 swim 和 sink 操作高效维护顺序。而且在 swim 和 sink 的过程中，可以根据具体的条件对元素进行比较，从而以 O(logn) 的复杂度完成按自定义规则入队，从而实现一个带有优先级的队列，而不是普通的先进先出的队列。

#### 为什么出队后要把末尾元素放到堆顶，然后进行下沉？

- 保持数组连续性
- 保持完全二叉树的结构
- 最小化操作复杂度

为了保持数组连续性，必须把末尾元素放到堆顶，否则数组就会产生空白位置；而遍历向前移动元素，则需要 O(n) 的复杂度，但是把末尾元素放到堆顶，然后进行下沉操作，这样只需要 O(logn) 的复杂度。

这就像在一个满教室换座位：

- 如果所有人都向前移动一个位置，则需要 O(n) 的复杂度
- 如果让最后一个人坐到第一个位置，然后其他人依次向前移动一个位置，再进行几次调换即可
  - 最后一个人坐到第一个位置，就相当于把末尾元素放到堆顶 O(1)
  - 其他人依次向前移动一个位置，就相当于进行下沉操作 O(logn)

#### 最后一个元素的值是否会影响整个下沉操作的复杂度？

最后一个元素的值确实会影响下沉的具体步数，但不会影响复杂度的量级。最好情况下交换一次即可，最坏情况下需要交换到叶子结点为止。

但是最坏情况下的复杂度仍然是 O(logn)，因为下沉操作最多需要从根节点一直交换到叶子节点，因此最大交换次数就是树的高度，而树的高度是 O(logn)。

#### 假设一个三个元素的最小堆，1 2 3 和 1 3 2 有区别吗?

没有区别，因为堆序性只要求父节点小于等于子节点，而没有要求左右子节点的大小关系。

在堆的操作过程中，以下几点是关键：

1. 堆顶是极值：
   - 对于最小堆，堆顶（根节点）是整个堆中最小的元素。
   - 对于最大堆，堆顶是整个堆中最大的元素。
2. 完全二叉树的结构：
   - 堆总是保持完全二叉树的结构，这意味着每一层都是满的，除了最后一层，且最后一层的节点尽可能靠左。
3. 父子节点关系：
   - 在最小堆中，每个父节点的值小于或等于其子节点的值。
   - 在最大堆中，每个父节点的值大于或等于其子节点的值。
4. 子树的左右节点值可能变化：
   - 在 swim 和 sink 操作过程中，子树的左右节点的值可能会发生变化。
   - 这些操作的目的是维护堆的性质（父节点与子节点的关系），而不是维护子节点之间的顺序。

因此，堆的内部结构在 swim 和 sink 操作后可能会发生变化，但堆的基本性质（堆顶是极值和完全二叉树结构）始终保持不变。
