## 索引堆

索引堆是一种特殊的堆，通过维护两个数组，可以实现在不改变原数据的情况下，通过索引直接访问和修改堆中的元素。

索引堆首先还是堆，整体的操作逻辑和概念与普通堆没有区别，只是多了两个数组：

### `indexes`

这个数组维护的是原始数组的下标信息，只不过是按照堆的顺序排列的。

在索引堆中，每次入队或者出队元素，不是操作原始数组，而是操作这个 indexes 数组。

这个数组就相当于是原始数组堆化以后的索引结构，通过这个数组，能直接按照正确的堆顺序访问到原始数组中的元素。

举例来说，如果原始数组是 `[15, 28, 12, 42, 30]`，那么堆化以后，indexes 数组就是 `[3, 1, 4, 0, 2]`。

       3(42) <- 堆顶为 3，表示 data[3] 是堆顶元素
      /  \
  1(28)  4(30)
   /   \
 0(15)  2(12)

 所以说，indexes 是从堆的角度出发：

- indexes[0] = 3：堆顶位置存放的是原始数组中下标为3的元素(42)
- indexes[1] = 1：堆的第二个位置存放的是原始数组中下标为1的元素(28)
- ...以此类推

### `reverse`

如果只有 indexes 数组，我们可以在不改变原数组的情况下，直接按照堆的顺序访问原数组。比如，indexes[0] = 3，我们就可以知道 data[3] 是堆顶元素。

但是，当我们操作原始数组的时候，我们没有办法知道当前元素在堆中的位置，所以需要 reverse 数组来辅助。

与 indexes 数组相反，reverse 数组是从原始数据的角度出发：

- reverse[3] = 0：原始数组中下标为3的元素(42)在堆中位于位置0（堆顶）
- reverse[1] = 1：原始数组中下标为1的元素(28)在堆中位于位置1
- ...以此类推

reverse 数组的作用就是，当我们知道原始数组中的元素下标时，通过 reverse 数组，我们可以快速找到该元素在堆中的位置。

**所以，当我们访问 indexes 的时候，使用的下标是堆的下标，而访问 reverse 的时候，使用的下标是原始数组的下标。**

- 用堆的下标访问 indexes 数组，从而知道对应的堆元素，实际上是原始数组中的哪个元素；
  - indexes[0] = 3：用堆的位置 0 去访问，知道堆顶对应原始数组中的位置 3
- 用原始数组的下标访问 reverse 数组，从而知道当前元素处于堆中的哪个位置。
  - reverse[3] = 0：用原始数组的位置 3 去访问，知道这个元素在堆中的位置是 0

有了这个特性，我们就会发现，indexes 和 reverse 数组是互为补充的，indexes 数组是堆的索引，reverse 数组是原始数组的索引。

并且，对于任意的 i，有 indexes[reverse[i]] = i，reverse[indexes[i]] = i。

### 实现

对于索引堆来说，最核心的部分在于，在堆的元素发生变化时，如何维护 indexes 和 reverse 数组。

